# RandomNoise.jl

[![Build Status](https://github.com/csimal/RandomNoise.jl/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/csimal/RandomNoise.jl/actions/workflows/CI.yml?query=branch%3Amain)
[![Coverage](https://codecov.io/gh/csimal/RandomNoise.jl/branch/main/graph/badge.svg)](https://codecov.io/gh/csimal/RandomNoise.jl)

This package provides a minimalist interface for using noise functions to generate pseudo random numbers.

Noise functions, also known as Counter-Based RNGs are another approach to traditional PRNGs, which have several advantages for parallel computation and procedural generation. While this package allows using noise functions as RNGs, it is mostly focused on using them as streams of random values that can be indexed in any order.

## Noise functions vs PRNGs

This GDC 2017 [talk](https://www.youtube.com/watch?v=LWFzPP8ZbdU) by Squirrel Eiserloh is an excellent introduction to noise functions.

Traditional Pseudo Random Number Generators (PRNGs) work by repeatedly applying a map that scrambles the bits of its inputs, starting from a given seed, so that when generating a sequence of pseudorandom numbers, the `n`-th term is to result of applying that map `n` times to the seed.

This has several downsides. First, PRNGs need to hold a state that gets mutated every time a new number is generated, making them ill-suited to parallel workflows. Second, the generated numbers can only be computed in order, so if one wants to access a sequence of pseudorandom numbers out of order, the best way is often to just store it in memory.

Noise Functions/CBRNGs on the other hand, work by applying a bit scrambling map once. That is, the `n`-th number in the sequence is computed by `noise(n)`.

These solve a lot of the problems with traditional PRNGs. They have no mutable state, and the sequence of numbers can be accessed out of order and at constant cost, making them ideal for parallel workflows. Furthermore, because the sequence of numbers can be accessed out of order, this removes the need to store them in memory for performance.

## Using this package
RandomNoise.jl defines an `AbstractNoise` type for all noise functions. All implementations of `AbstractNoise` must implement a single method `noise(n,rng)` that returns the `n`-th term of the sequence generated by the noise function.

```julia
sqn = SquirrelNoise5()
noise(1, sqn)
```
## Noise functions provided in this package
RandomNoise.jl currently provides two noise functions
* `SquirrelNoise5` a 32-bit noise function, originally by Squirrel Eiserloh
* `HashNoise` a 64-bit noise function based on `Base.hash`

In addition, optional support for Random123.jl's CBRNGs is provided via [Requires.jl](https://github.com/JuliaPackaging/Requires.jl). So both RandomNoise and Random123 need to be loaded to use them.

```julia
rng = Threefry2x()
noise(0, rng)
```
## Using Noise functions in `rand()`
Any noise function can be used as a sequential PRNG simply by creating a counter and incrementing it each time a new number is generated. Examples of such *Counter Based RNGs* (CBRNGs) can be found in the [Random123.jl](https://github.com/JuliaRandom/Random123.jl) package.

The noise functions defined in this package can be made into CBRNGs by passing them to a `NoiseRNG` object.
```julia
rng = SquirrelNoise5()
rand(rng)
```
Note: Since Random123.jl already defines `rand` for it's CBRNGs, we do not passing them to `NoiseRNG`.


## BigCrush benchmarks
TODO
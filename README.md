# RandomNoise.jl

[![Build Status](https://github.com/csimal/RandomNoise.jl/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/csimal/RandomNoise.jl/actions/workflows/CI.yml?query=branch%3Amain)
[![Coverage](https://codecov.io/gh/csimal/RandomNoise.jl/branch/main/graph/badge.svg)](https://codecov.io/gh/csimal/RandomNoise.jl)

This package provides a minimalist interface for using noise functions as an alternative to pseudorandom number generators.

Noise functions, also known as Counter-Based RNGs are another approach to traditional PRNGs, which have several advantages for parallel computation and procedural generation. While this package allows using noise functions as sequential RNGs, it is mostly focused on using them as streams of random values that can be indexed in any order at constant cost and memory overhead.

## Using noise functions
RandomNoise.jl defines an `AbstractNoise` type for all noise functions. All implementations of `AbstractNoise` must implement a single method `noise(n,rng)` that returns the `n`-th term of the sequence generated by the noise function.

```julia
sqn = SquirrelNoise5()
noise(1, sqn)
```
Additionally, some noise functions can be provided with a seed.
```julia
sqn = SquirrelNoise5(42)
noise(1, sqn)
```

## Noise functions provided in this package
RandomNoise.jl currently provides two noise functions
* `SquirrelNoise5` a 32-bit noise function, originally by [Squirrel Eiserloh](https://pastebin.com/dVZcMJJQ)
* `HashNoise` a 64-bit noise function based on `Base.hash`

In addition, optional support for Random123.jl's CBRNGs is provided via [Requires.jl](https://github.com/JuliaPackaging/Requires.jl). So both RandomNoise and Random123 need to be loaded to use them.

```julia
using RandomNoise
using Random123

rng = Threefry2x()
noise(0, rng)
```

Which one to use depends on your use case. Since `Base.hash` is subject to change, and is not really intended for this anyway, it should probably be avoided when reproducibility across Julia versions or the quality of the random numbers is important. Use the generators from Random123 if you need good quality random numbers.

## Using noise functions in `rand()`
Any noise function can be used as a sequential PRNG simply by creating a counter and incrementing it each time a new number is generated. Examples of such *Counter Based RNGs* (CBRNGs) can be found in the [Random123.jl](https://github.com/JuliaRandom/Random123.jl) package.

The noise functions defined in this package can be made into CBRNGs by passing them to a `NoiseRNG` object.
```julia
rng = NoiseRNG(SquirrelNoise5())
rand(rng)
```
Note: Since Random123.jl already defines `rand` for it's CBRNGs, we do not support passing them to `NoiseRNG`.

## NoiseArrays

This package exports a `NoiseArray` type that functions like a read-only array of random values, but which doesn't allocate any memory for its elements, and instead computes them on demand.

The generic constructor of `NoiseArray` looks like this

```Julia
A = NoiseArray(rng, transform, dims...)
```
where `rng` is any noise function, `transform` is a function that is applied to the output of `noise(i,rng)` to obtain the elements of the array, and `dims` is the dimensions of the array.

You can also specify an element type like this
```Julia
A = NoiseArray{T}(rng, transform, dims...)
```
The output of `transform` always gets converted to type `T`.

We also provide a specific transform for floating point numbers uniformly distributed in the interval [0,1).
```Julia
A = NoiseArray(rng, NoiseUniform{T}, dims)
```

Finally, any `UnivariateDistribution` from the [Distributions.jl](https://juliastats.org/Distributions.jl/stable/univariate/) package can be used as a transform. The elements of the array will be samples from that distribution.

```Julia
A = NoiseArray(rng, Bernoulli(), dims)
```

---
## Noise functions vs PRNGs

This GDC 2017 [talk](https://www.youtube.com/watch?v=LWFzPP8ZbdU) by Squirrel Eiserloh is an excellent introduction to noise functions.

Traditional Pseudo Random Number Generators (PRNGs) work by repeatedly applying a map that scrambles the bits of its inputs, starting from a given seed, so that when generating a sequence of pseudorandom numbers, the `n`-th term is to result of applying that map `n` times to the seed.

This has several downsides. First, PRNGs need to hold a state that gets mutated every time a new number is generated, making them ill-suited to parallel workflows. Second, the generated numbers can only be computed in order, so if one wants to access a sequence of pseudorandom numbers out of order, the best way is often to just store it in memory.

Noise Functions/CBRNGs on the other hand, work by applying a bit-scrambling map once. That is, the `n`-th number in the sequence is computed by `noise(n)`.

These solve a lot of the problems with traditional PRNGs. They have no mutable state, and the sequence of numbers can be accessed out of order and at constant cost, making them ideal for parallel workflows. Furthermore, because the sequence of numbers can be accessed out of order, this removes the need to store them in memory for performance.


## BigCrush benchmarks
TODO
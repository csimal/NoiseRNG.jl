# RandomNoise.jl

[![Build Status](https://github.com/csimal/RandomNoise.jl/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/csimal/RandomNoise.jl/actions/workflows/CI.yml?query=branch%3Amain)
[![Coverage](https://codecov.io/gh/csimal/RandomNoise.jl/branch/main/graph/badge.svg)](https://codecov.io/gh/csimal/RandomNoise.jl)
[![Aqua QA](https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg)](https://github.com/JuliaTesting/Aqua.jl)

This package provides a minimalist interface for using noise functions as an alternative to pseudorandom number generators.

Noise functions, also known as Counter-Based RNGs are another approach to traditional PRNGs, which have several advantages for parallel computation and procedural generation. While this package allows using noise functions as sequential RNGs, it is mostly focused on using them as streams of random values that can be indexed in any order at constant cost and memory overhead.

## Using noise functions
RandomNoise.jl defines an `AbstractNoise` type for all noise functions. All implementations of `AbstractNoise` must implement a single method `noise(n,rng)` that returns the `n`-th term of the sequence generated by the noise function.

```julia-repl
julia> sqn = SquirrelNoise5()
SquirrelNoise5(0x00000000)

julia> noise(1, sqn)
0xc895cb1d
```
Additionally, most noise functions can be provided with a seed. Unlike PRNGs, this generates a completely different sequence, rather than jumping at a different point in the same sequence.
```julia-repl
julia> sqn = SquirrelNoise5(42)
SquirrelNoise5(0x0000002a)

julia> noise(1, sqn)
0xd6c56929
```

## Noise functions implemented in this package
RandomNoise.jl currently provides two noise functions
* `SquirrelNoise5` a 32-bit noise function, originally by [Squirrel Eiserloh](https://pastebin.com/dVZcMJJQ)
* `SquirrelNoise5x2` a 64-bit noise function, consisting of two stacked `SquirrelNoise5`
* `Murmur3Noise` a 32-bit noise function based on the Murmur3 hash function

In addition, support for [Random123.jl](https://github.com/JuliaRandom/Random123.jl)'s CBRNGs is provided via immutable wrapper types. Both RandomNoise and Random123 need to be loaded to use them.

```julia
using RandomNoise
using Random123

rng = Threefry2x()
tfn = ThreefryNoise(rng)
noise(0, tfn)
```
The noise functions implemented in this package are more lightweight, but have yet to be rigorously tested. Use the ones from Random123 if you want some battle-tested generators.

## Using noise functions in `rand()`
Any noise function can be used as a sequential PRNG simply by creating a counter and incrementing it each time a new number is generated. Examples of such *Counter Based RNGs* (CBRNGs) can be found in the [Random123.jl](https://github.com/JuliaRandom/Random123.jl) package.

The noise functions defined in this package can be made into CBRNGs by passing them to a `NoiseRNG` object.
```julia-repl
julia> rng = NoiseRNG(SquirrelNoise5())
NoiseRNG{UInt32, SquirrelNoise5}(SquirrelNoise5(0x00000000), 0x00000000)

julia> rand(rng)
0.08778560161590576
```
Note: Since Random123.jl already defines `rand` for it's CBRNGs, we do not support passing them to `NoiseRNG`.

---
## Noise functions vs PRNGs

This GDC 2017 [talk](https://www.youtube.com/watch?v=LWFzPP8ZbdU) by Squirrel Eiserloh is an excellent introduction to noise functions.

Traditional Pseudo Random Number Generators (PRNGs) work by repeatedly applying a map that scrambles the bits of its inputs, starting from a given seed, so that when generating a sequence of pseudorandom numbers, the `n`-th term is to result of applying that map `n` times to the seed.

This has several downsides. First, PRNGs need to hold a state that gets mutated every time a new number is generated, making them ill-suited to parallel workflows. Second, the generated numbers can only be computed in order, so if one wants to access a sequence of pseudorandom numbers out of order, the best way is often to just store it in memory.

Noise Functions/CBRNGs on the other hand, work by applying a bit-scrambling map once. That is, the `n`-th number in the sequence is computed by `noise(n)`.

These solve a lot of the problems with traditional PRNGs. They have no mutable state, and the sequence of numbers can be accessed out of order and at constant cost, making them ideal for parallel workflows. Furthermore, because the sequence of numbers can be accessed out of order, this removes the need to store them in memory for performance.


## Benchmarks

The `SquirrelNoise5`, `SquirrelNoise5x2` and `Murmur3Noise` were tested with the BigCrush benchmark from [RNGTest](https://github.com/JuliaRandom/RNGTest.jl). Both variants of SquirrelNoise5 fail 8 tests (Gap and MaxOft), while Murmur3Noise fails 10 (BirthdaySpacings, Gap, MaxOft and SumCollector). See `benchmarks/results` for more details.